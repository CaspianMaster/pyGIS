
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Learn how to interpolate spatial data using python. Interpolation is the process of using locations with known, sampled values (of a phenomenon) to estimate the values at unknown, unsampled areas." lang="en" name="description" xml:lang="en" />
<meta content="python, geospatial, interpolation, vector, shapefile" name="keywords" />
<meta content="en_US" property="og:locale" />

    <title>Spatial Interpolation &#8212; Open Source Geospatial Programming &amp; Remote Sensing</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.c441f2ba0852f4cabcb80105e3a46ae6.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="canonical" href="https://mmann1123.github.io/pyGIS/docs/e_interpolation.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Raster Operations" href="e_raster_op_intro.html" />
    <link rel="prev" title="Merge Data &amp; Dissolve Polygons" href="e_vector_merge_dissolve.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />


<!-- Opengraph tags -->
<meta property="og:url"         content="https://mmann1123.github.io/pyGIS/docs/e_interpolation.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Spatial Interpolation" />
<meta property="og:description" content="Spatial Interpolation    Learning Objectives  Conduct various types of interpolation on point dataset  Obtain interpolated values at specified unsampled locatio" />
<meta property="og:image"       content="https://mmann1123.github.io/pyGIS/_static/pygis.png" />

<meta name="twitter:card" content="summary" />


  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/pygis.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Open Source Geospatial Programming & Remote Sensing</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="a_intro.html">
   PyGIS - Open Source Geospatial Programming &amp; Remote Sensing
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Get Started
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="b_intro_py.html">
   Welcome - Let’s get started
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="b_about_py.html">
   Getting Started in Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="b_getting_started.html">
   Setting up Your Python Environment
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="b_python_by_example.html">
   An Introductory Example
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="b_learn_more.html">
   Learn More
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Data Types
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="c_features.html">
   Geospatial Data
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="c_store_features.html">
   Data Storage Formats
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="c_vectors.html">
   Geospatial Vector Data
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="c_rasters.html">
   Geospatial Raster Data
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Nature of Coordinate Systems
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="d_crs_what_is_it.html">
   What is a CRS?
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="d_understand_crs_codes.html">
   Understanding CRS codes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="d_affine.html">
   Affine Transforms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="d_vector_crs_intro.html">
   Vector Coordinate Reference Systems (CRS)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="d_raster_crs_intro.html">
   Raster Coordinate Reference Systems (CRS)
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Vector Operations
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="e_vector_op_intro.html">
   Vector Operations
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="e_attributes.html">
     Attributes &amp; Indexing for Vector Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="e_new_vectors.html">
     Creating Geospatial Vector Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="e_vector_overlay.html">
     Vector Overlays and Joins
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="e_extraction.html">
     Extracting Spatial Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="e_summarize_vector.html">
     Summarizing Point Patterns
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="e_vector_merge_dissolve.html">
     Merge Data &amp; Dissolve Polygons
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Spatial Interpolation
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="e_raster_op_intro.html">
   Raster Operations
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="e_raster_reproject.html">
     Reproject Rasters
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Remote Sensing
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="f_rs_intro.html">
   Remote Sensing with Python using Geowombat
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="f_rs_io.html">
     Opening Remote Sensed Images
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="f_rs_edit.html">
     Editing Rasters and Remotely Sensed Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="f_rs_plot.html">
     Plot Remote Sensed Images
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="f_rs_crs.html">
     Remote Sensing Coordinate Reference Systems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="f_rs_mosaic.html">
     Handle Multiple Remotely Sensed Images
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="f_rs_config.html">
     Configuration manager
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="f_rs_band_math.html">
     Band Math &amp; Vegetation Indices
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="f_rs_extraction.html">
     Raster Data Extraction
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="../_sources/docs/e_interpolation.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/docs/e_interpolation.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/mmann1123/pyGIS"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/mmann1123/pyGIS/issues/new?title=Issue%20on%20page%20%2Fdocs/e_interpolation.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/mmann1123/pyGIS/edit/main/./pygis/docs/e_interpolation.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                    title="Fullscreen mode"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/mmann1123/pyGIS/main?urlpath=tree/./pygis/docs/e_interpolation.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i>
            Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#thiessen-polygons-voronoi-diagrams">
   Thiessen Polygons (Voronoi Diagrams)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#k-nearest-neighbors">
   K-Nearest Neighbors
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#kriging">
   Kriging
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#method-1-using-pykrige">
     Method 1 - Using
     <code class="docutils literal notranslate">
      <span class="pre">
       PyKrige
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#method-2-using-scikit-learn">
     Method 2- Using
     <code class="docutils literal notranslate">
      <span class="pre">
       scikit-learn
      </span>
     </code>
    </a>
   </li>
  </ul>
 </li>
</ul>

        </nav>
        
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="spatial-interpolation">
<h1>Spatial Interpolation<a class="headerlink" href="#spatial-interpolation" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<div class="admonition-learning-objectives admonition">
<p class="admonition-title">Learning Objectives</p>
<ul class="simple">
<li><p>Conduct various types of interpolation on point dataset</p></li>
<li><p>Obtain interpolated values at specified unsampled locations</p></li>
</ul>
</div>
<div class="admonition-review admonition">
<p class="admonition-title">Review</p>
<ul class="simple">
<li><p><a class="reference internal" href="c_vectors.html"><span class="doc std std-doc">Geospatial Vector Data</span></a></p></li>
<li><p><a class="reference internal" href="e_attributes.html"><span class="doc std std-doc">Attributes &amp; Indexing for Vector Data</span></a></p></li>
<li><p><a class="reference internal" href="e_new_vectors.html"><span class="doc std std-doc">Creating Geospatial Vector Data</span></a></p></li>
<li><p><a class="reference internal" href="e_vector_merge_dissolve.html"><span class="doc std std-doc">Merge Data &amp; Dissolve Polygons</span></a></p></li>
</ul>
</div>
<hr class="docutils" />
<p>Interpolation is the process of using locations with known, sampled values (of a phenomenon) to estimate the values at unknown, unsampled areas <a class="footnote-reference brackets" href="#bolstad" id="id1">1</a>. In this chapter, we will explore three interpolation methods: Thiessen polygons (Voronoi diagrams), k-nearest neighbors (KNN), and kriging.</p>
<p>We will first begin by importing modules (click the + below to show code cell).</p>
<div class="cell tag_hide-cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import modules</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pykrige.ok</span> <span class="kn">import</span> <span class="n">OrdinaryKriging</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">import</span> <span class="nn">rasterio.mask</span>
<span class="kn">from</span> <span class="nn">rasterio.plot</span> <span class="kn">import</span> <span class="n">show</span>
<span class="kn">from</span> <span class="nn">rasterio.transform</span> <span class="kn">import</span> <span class="n">Affine</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Voronoi</span><span class="p">,</span> <span class="n">voronoi_plot_2d</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">box</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">Point</span>
<span class="kn">from</span> <span class="nn">sklearn.gaussian_process</span> <span class="kn">import</span> <span class="n">GaussianProcessRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">r2_score</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsRegressor</span>
</pre></div>
</div>
</div>
</div>
<p>We will utilize shapefiles of San Francisco Bay Area county boundaries and rainfall “values” that were “sampled” in the Bay Area. We will load in the data and reproject the data (click the + below to show code cell).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is critical to use a ‘projected’ coordinate system when doing interpolation. If you keep your data in geographic lat lon distances will vary significantly as you move up and down in latitude… since interpolation depends on distance as a way of establishing relationships this would be a problem… a big one.</p>
</div>
<div class="cell tag_hide-cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load data</span>

<span class="c1"># County boundaries</span>
<span class="c1"># Source: https://opendata.mtc.ca.gov/datasets/san-francisco-bay-region-counties-clipped?geometry=-125.590%2C37.123%2C-119.152%2C38.640</span>
<span class="n">counties</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;../_static/e_vector_shapefiles/sf_bay_counties/sf_bay_counties.shp&quot;</span><span class="p">)</span>

<span class="c1"># Rainfall measurement &quot;locations&quot;</span>
<span class="c1"># Source: https://earthworks.stanford.edu/catalog/stanford-td754wr4701</span>
<span class="c1"># Modified by author by clipping raster to San Francisco Bay Area, generating random points, and extracting raster values (0-255) to the points</span>
<span class="n">rainfall</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;../_static/e_vector_shapefiles/sf_bay_rainfall/sf_bay_rainfall.shp&quot;</span><span class="p">)</span>

<span class="c1"># Reproject data to CA Teale Albert</span>
<span class="c1"># https://nrm.dfg.ca.gov/FileHandler.ashx?DocumentID=109326&amp;inline</span>
<span class="n">proj</span> <span class="o">=</span> <span class="s2">&quot;+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +ellps=GRS80 +datum=NAD83 +units=m +no_defs &quot;</span>
<span class="n">counties</span> <span class="o">=</span> <span class="n">counties</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
<span class="n">rainfall</span> <span class="o">=</span> <span class="n">rainfall</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we’ll prepare the data for geoprocessing (click the + below to show code cell).</p>
<div class="cell tag_hide-cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get X and Y coordinates of rainfall points</span>
<span class="n">x_rain</span> <span class="o">=</span> <span class="n">rainfall</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
<span class="n">y_rain</span> <span class="o">=</span> <span class="n">rainfall</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">y</span>

<span class="c1"># Create list of XY coordinate pairs</span>
<span class="n">coords_rain</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_rain</span><span class="p">,</span> <span class="n">y_rain</span><span class="p">)]</span>

<span class="c1"># Get extent of counties feature</span>
<span class="n">min_x_counties</span><span class="p">,</span> <span class="n">min_y_counties</span><span class="p">,</span> <span class="n">max_x_counties</span><span class="p">,</span> <span class="n">max_y_counties</span> <span class="o">=</span> <span class="n">counties</span><span class="o">.</span><span class="n">total_bounds</span>

<span class="c1"># Get list of rainfall &quot;values&quot;</span>
<span class="n">value_rain</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rainfall</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">])</span>

<span class="c1"># Create a copy of counties dataset</span>
<span class="n">counties_dissolved</span> <span class="o">=</span> <span class="n">counties</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Add a field with constant value of 1</span>
<span class="n">counties_dissolved</span><span class="p">[</span><span class="s2">&quot;constant&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Dissolve all counties to create one polygon</span>
<span class="n">counties_dissolved</span> <span class="o">=</span> <span class="n">counties_dissolved</span><span class="o">.</span><span class="n">dissolve</span><span class="p">(</span><span class="n">by</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We will also define a function for exporting rasters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">export_kde_raster</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Export and save a kernel density raster.&#39;&#39;&#39;</span>

    <span class="c1"># Get resolution</span>
    <span class="n">xres</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">XX</span><span class="p">)</span>
    <span class="n">yres</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">YY</span><span class="p">)</span>

    <span class="c1"># Set transform</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">Affine</span><span class="o">.</span><span class="n">translation</span><span class="p">(</span><span class="n">min_x</span> <span class="o">-</span> <span class="n">xres</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">min_y</span> <span class="o">-</span> <span class="n">yres</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Affine</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">xres</span><span class="p">,</span> <span class="n">yres</span><span class="p">)</span>

    <span class="c1"># Export array as raster</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
            <span class="n">filename</span><span class="p">,</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
            <span class="n">driver</span> <span class="o">=</span> <span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="n">proj</span><span class="p">,</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">new_dataset</span><span class="p">:</span>
            <span class="n">new_dataset</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>With any model used for prediction, it is important to assess the model fit for unobserved locations (or the accuracy of the values predicted by the model in relation to their actual values). Thus, in order to assess the fit, we break our data into two portions, a “training” data set used to train the model, and a “testing” set that remains “unseen” by the model but can be used to assess model performance. Effectively, we can use this “unseen” testing subset to validate the model because we can compare their true values with the estimated value from the model prediction.</p>
<p>We will separate our rainfall dataset into two subsets: one for training and the other for testing. These subsets will be used in our KNN and kriging analyses.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Split data into testing and training sets</span>
<span class="n">coords_rain_train</span><span class="p">,</span> <span class="n">coords_rain_test</span><span class="p">,</span> <span class="n">value_rain_train</span><span class="p">,</span> <span class="n">value_rain_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">coords_rain</span><span class="p">,</span> <span class="n">value_rain</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.20</span><span class="p">,</span> <span class="n">random_state</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create separate GeoDataFrames for testing and training sets</span>
<span class="n">rain_train_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">coords_rain_train</span><span class="p">],</span> <span class="n">crs</span> <span class="o">=</span> <span class="n">proj</span><span class="p">)</span>
<span class="n">rain_train_gdf</span><span class="p">[</span><span class="s2">&quot;Actual_Value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_rain_train</span>
<span class="n">rain_test_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">coords_rain_test</span><span class="p">],</span> <span class="n">crs</span> <span class="o">=</span> <span class="n">proj</span><span class="p">)</span>
<span class="n">rain_test_gdf</span><span class="p">[</span><span class="s2">&quot;Actual_Value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_rain_test</span>

<span class="c1"># Get minimum and maximum coordinate values of rainfall training points</span>
<span class="n">min_x_rain</span><span class="p">,</span> <span class="n">min_y_rain</span><span class="p">,</span> <span class="n">max_x_rain</span><span class="p">,</span> <span class="n">max_y_rain</span> <span class="o">=</span> <span class="n">rain_train_gdf</span><span class="o">.</span><span class="n">total_bounds</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s plot our data!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create subplots</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># Stylize plots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;bmh&#39;</span><span class="p">)</span>

<span class="c1"># Plot data</span>
<span class="n">counties</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;bisque&#39;</span><span class="p">,</span> <span class="n">edgecolor</span> <span class="o">=</span> <span class="s1">&#39;dimgray&#39;</span><span class="p">)</span>
<span class="n">rain_train_gdf</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;limegreen&#39;</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">rain_test_gdf</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;royalblue&#39;</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1"># Set title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;San Francisco Bay Area - Rainfall Measurement Locations&#39;</span><span class="p">,</span> <span class="n">fontdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="s1">&#39;fontweight&#39;</span> <span class="p">:</span> <span class="s1">&#39;3&#39;</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, &#39;San Francisco Bay Area - Rainfall Measurement Locations&#39;)
</pre></div>
</div>
<img alt="../_images/e_interpolation_11_1.png" src="../_images/e_interpolation_11_1.png" />
</div>
</div>
<p>In the map above, the green and blue points are the rainfall points that we loaded separated into the training set and testing set, respectively.</p>
<div class="section" id="thiessen-polygons-voronoi-diagrams">
<h2>Thiessen Polygons (Voronoi Diagrams)<a class="headerlink" href="#thiessen-polygons-voronoi-diagrams" title="Permalink to this headline">¶</a></h2>
<p>Thiessen polygons (also known as Voronoi diagrams) polygons allow us to perform nearest neighbor interpolation, which is perhaps the most basic type of interpolation. Thiessen polygons are be constructed around each sampled point so all the space within a specific polygon is closest in distance to that sampled point (as compared to other sampled points). Then, to perform nearest neighbor interpolation, all that space is assigned the value of that sampled point. <a class="footnote-reference brackets" href="#bolstad" id="id2">1</a></p>
<p>We can use the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Voronoi.html"><code class="docutils literal notranslate"><span class="pre">scipy</span></code> package</a> to create Thiessen polygons. After running the <code class="docutils literal notranslate"><span class="pre">Voronoi()</span></code> function, we can use the <code class="docutils literal notranslate"><span class="pre">vertices</span></code> attribute to get a list of vertices, which we can subsequently use to generate polygons.</p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>When creating Thiessen polygons, the sample points toward the edges of the point shapefile’s extent will have infinite Voronoi regions, because not all sides of these edge points have adjacent sample points that would constrain the regions. Consequently, these infinite regions will not be exported. To mitigate this issue, we can create dummy points well beyond the extent of our datasets, which will create finite Voronoi regions for all of our actual sample points. Then, we can clip the regions to our extent shapefile (creating dummy points far away from our actual sample points will ensure the dummy points and their infinite Voronoi regions do not interfere with the sample points and their associated finite Voronoi regions after all regions are clipped).</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extend extent of counties feature by using buffer</span>
<span class="n">counties_buffer</span> <span class="o">=</span> <span class="n">counties</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>

<span class="c1"># Get extent of buffered input feature</span>
<span class="n">min_x_cty_tp</span><span class="p">,</span> <span class="n">min_y_cty_tp</span><span class="p">,</span> <span class="n">max_x_cty_tp</span><span class="p">,</span> <span class="n">max_y_cty_tp</span> <span class="o">=</span> <span class="n">counties_buffer</span><span class="o">.</span><span class="n">total_bounds</span>

<span class="c1"># Use extent to create dummy points and add them to list of coordinates</span>
<span class="n">coords_tp</span> <span class="o">=</span> <span class="n">coords_rain_train</span> <span class="o">+</span> <span class="p">[[</span><span class="n">min_x_cty_tp</span><span class="p">,</span> <span class="n">min_y_cty_tp</span><span class="p">],</span> <span class="p">[</span><span class="n">max_x_cty_tp</span><span class="p">,</span> <span class="n">min_y_cty_tp</span><span class="p">],</span>
                                 <span class="p">[</span><span class="n">max_x_cty_tp</span><span class="p">,</span> <span class="n">max_y_cty_tp</span><span class="p">],</span> <span class="p">[</span><span class="n">min_x_cty_tp</span><span class="p">,</span> <span class="n">max_y_cty_tp</span><span class="p">]]</span>

<span class="c1"># Compute Voronoi diagram</span>
<span class="n">tp</span> <span class="o">=</span> <span class="n">Voronoi</span><span class="p">(</span><span class="n">coords_tp</span><span class="p">)</span>

<span class="c1"># Create empty list of hold Voronoi polygons</span>
<span class="n">tp_poly_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Create a polygon for each region</span>
<span class="c1"># &#39;regions&#39; attribute provides a list of indices of the vertices (in the &#39;vertices&#39; attribute) that make up the region</span>
<span class="c1"># Source: https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Voronoi.html</span>
<span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">tp</span><span class="o">.</span><span class="n">regions</span><span class="p">:</span>

    <span class="c1"># Ignore region if -1 is in the list (based on documentation)</span>
    <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>

        <span class="c1"># Return to top of loop</span>
        <span class="k">continue</span>

    <span class="c1"># Otherwise, pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Check that region list has values in it</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

        <span class="c1"># Create a polygon by using the region list to call the correct elements in the &#39;vertices&#39; attribute</span>
        <span class="n">tp_poly_region</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tp</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">region</span><span class="p">]))</span>

        <span class="c1"># Append polygon to list</span>
        <span class="n">tp_poly_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tp_poly_region</span><span class="p">)</span>

    <span class="c1"># If no values, return to top of loop</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">continue</span>

<span class="c1"># Create GeoDataFrame from list of polygon regions</span>
<span class="n">tp_polys</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">tp_poly_list</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">],</span> <span class="n">crs</span> <span class="o">=</span> <span class="n">proj</span><span class="p">)</span>

<span class="c1"># Clip polygon regions to the counties boundary</span>
<span class="n">tp_polys_clipped</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">tp_polys</span><span class="p">,</span> <span class="n">counties_dissolved</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>A spatial join can be conducted to assign the rainfall training “values” to its associated Thiessen polygon.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># If rainfall point within the polygon, assign that rainfall value to the polygon</span>
<span class="n">tp_polys_clipped_values</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">rain_train_gdf</span><span class="p">,</span> <span class="n">tp_polys_clipped</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;within&#39;</span><span class="p">)</span>

<span class="c1"># Drop un-needed column</span>
<span class="n">tp_polys_clipped_values</span> <span class="o">=</span> <span class="n">tp_polys_clipped_values</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;index_left&quot;</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Rename column</span>
<span class="n">tp_polys_clipped_values</span> <span class="o">=</span> <span class="n">tp_polys_clipped_values</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Actual_Value&quot;</span><span class="p">:</span> <span class="s2">&quot;VALUE_Thiessen&quot;</span><span class="p">})</span>

<span class="c1"># Display head of attribute table</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attribute Table: Thiessen Polygon Interpolated Values&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">tp_polys_clipped_values</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Attribute Table: Thiessen Polygon Interpolated Values
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>VALUE_Thiessen</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>31</td>
      <td>POLYGON ((-112269.760 -116571.101, -118993.986...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>30</td>
      <td>POLYGON ((-123619.813 -116449.307, -118993.986...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>58</td>
      <td>POLYGON ((-246788.933 78896.506, -260275.835 8...</td>
    </tr>
    <tr>
      <th>3</th>
      <td>62</td>
      <td>POLYGON ((-260275.835 80739.699, -260874.252 8...</td>
    </tr>
    <tr>
      <th>4</th>
      <td>66</td>
      <td>POLYGON ((-237973.581 88639.620, -246524.775 8...</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>A second spatial join can be conducted to assign those values from the Thiessen polygons to the points from the testing dataset (only if a test point falls within a polygon). We can subsequently get the out-of-sample r-squared value, which is calculated by using the data points that the model did not use (the testing dataset) and comparing the testing dataset’s actual values to the values as predicted by the model.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># If test point is within a polygon, assign that polygon&#39;s value to the test point</span>
<span class="n">rain_test_pred_tp</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">rain_test_gdf</span><span class="p">,</span> <span class="n">tp_polys_clipped_values</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">op</span> <span class="o">=</span> <span class="s1">&#39;within&#39;</span><span class="p">)</span>

<span class="c1"># Drop un-needed column</span>
<span class="n">rain_test_pred_tp</span> <span class="o">=</span> <span class="n">rain_test_pred_tp</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;index_right&quot;</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Rename column</span>
<span class="n">rain_test_pred_tp</span> <span class="o">=</span> <span class="n">rain_test_pred_tp</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Actual_Value&quot;</span><span class="p">:</span> <span class="s2">&quot;VALUE_Actual&quot;</span><span class="p">,</span> <span class="s2">&quot;VALUE_Thiessen&quot;</span><span class="p">:</span> <span class="s2">&quot;VALUE_Predict&quot;</span><span class="p">})</span>

<span class="c1"># Generate out-of-sample R^2</span>
<span class="n">out_r_squared_tp</span> <span class="o">=</span> <span class="n">r2_score</span><span class="p">(</span><span class="n">rain_test_pred_tp</span><span class="o">.</span><span class="n">VALUE_Actual</span><span class="p">,</span> <span class="n">rain_test_pred_tp</span><span class="o">.</span><span class="n">VALUE_Predict</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Thiessen polygon out-of-sample r-squared: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">out_r_squared_tp</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

<span class="c1"># Display attribute table</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attribute Table: Testing Dataset Interpolated Values - Thiessen Polygon Method&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">rain_test_pred_tp</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Thiessen polygon out-of-sample r-squared: 0.89

Attribute Table: Testing Dataset Interpolated Values - Thiessen Polygon Method
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>VALUE_Actual</th>
      <th>VALUE_Predict</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POINT (-229633.026 40063.754)</td>
      <td>56</td>
      <td>62</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POINT (-273849.350 92453.689)</td>
      <td>73</td>
      <td>91</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Plotting the data, we see that each polygon has one green training point (and vice-versa). All space within one polygon is closest to the known training point (green dot) within the polygon. The testing points (blue dots) are assigned the value of the Thiessen polygon in which it falls.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create subplots</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>

<span class="c1"># Stylize plots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;bmh&#39;</span><span class="p">)</span>

<span class="c1"># Plot data</span>
<span class="n">counties_dissolved</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span> <span class="o">=</span> <span class="s1">&#39;dimgray&#39;</span><span class="p">)</span>
<span class="n">tp_polys_clipped</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;Set3&#39;</span><span class="p">,</span> <span class="n">edgecolor</span> <span class="o">=</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">rain_train_gdf</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;limegreen&#39;</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">rain_test_pred_tp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;royalblue&#39;</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">15</span><span class="p">)</span>

<span class="c1"># Iterate through each rainfall train point to add a label with its value to the plot</span>
<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rain_train_gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">Actual_Value</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

<span class="c1"># Iterate through each rainfall test point to add a label with its value to the plot</span>
<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rain_test_pred_tp</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">VALUE_Predict</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

<span class="c1"># Set title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;San Francisco Bay Area - Rainfall Measurement Locations &amp; Thiessen Polygons&#39;</span><span class="p">,</span> <span class="n">fontdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="s1">&#39;fontweight&#39;</span> <span class="p">:</span> <span class="s1">&#39;3&#39;</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, &#39;San Francisco Bay Area - Rainfall Measurement Locations &amp; Thiessen Polygons&#39;)
</pre></div>
</div>
<img alt="../_images/e_interpolation_19_1.png" src="../_images/e_interpolation_19_1.png" />
</div>
</div>
<p>In addition to <code class="docutils literal notranslate"><span class="pre">vertices</span></code>, there are a few other attributes we can call if we want to further explore the polygons. These attributes will provide actual values (e.g., vertices) or provide the indices for querying other attributes. <a class="footnote-reference brackets" href="#scipy-voronoi" id="id3">2</a></p>
<p>In the example below, we demonstrate how to extract the value of one of the Thiessen polygons at a new location for which we want a predicted value. We use the <code class="docutils literal notranslate"><span class="pre">point_region</span></code> attribute to provide the index of a point’s Voronoi region, and we use that index to get the region in <code class="docutils literal notranslate"><span class="pre">regions</span></code>. That provides indices of the vertices that make up the polygon, which we use to get the appropriate values in <code class="docutils literal notranslate"><span class="pre">vertices</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set index for feature of interest</span>
<span class="n">feature_index_one</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># Get a Voronoi polygon for one feature</span>
<span class="c1"># &#39;point_region&#39; attribute provides the index of the Voronoi region belonging to a specified point</span>
<span class="c1"># Can use the index to call the appropriate element in the &#39;regions&#39; attribute</span>
<span class="n">tp_poly_region_one</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">tp</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">point_region</span><span class="p">[</span><span class="n">feature_index_one</span><span class="p">]]])</span>

<span class="c1"># Create GeoDataFrame for polygon</span>
<span class="n">tp_poly_region_one</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">([</span><span class="n">tp_poly_region_one</span><span class="p">],</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">],</span> <span class="n">crs</span> <span class="o">=</span> <span class="n">proj</span><span class="p">)</span>

<span class="c1"># Clip polygon to county boundary</span>
<span class="n">tp_poly_region_one</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">tp_poly_region_one</span><span class="p">,</span> <span class="n">counties_dissolved</span><span class="p">)</span>

<span class="c1"># Get the equivalent feature from the rainfall dataset</span>
<span class="n">rain_one</span> <span class="o">=</span> <span class="n">rain_train_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">feature_index_one</span><span class="p">]]</span>

<span class="c1"># Add the rainfall value to the polygon attribute table</span>
<span class="n">tp_poly_region_one</span><span class="p">[</span><span class="s2">&quot;VALUE_Predict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rain_one</span><span class="p">[</span><span class="s2">&quot;Actual_Value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

<span class="c1"># Display attribute table</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attribute Table: Thiessen Polygon Interpolated Value&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">tp_poly_region_one</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Attribute Table: Thiessen Polygon Interpolated Value
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>VALUE_Predict</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POLYGON ((-173793.383 -34945.420, -175342.667 ...</td>
      <td>38</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Here’s how that one Thiessen polygon looks.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create subplots</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># Stylize plots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;bmh&#39;</span><span class="p">)</span>

<span class="c1"># Plot data</span>
<span class="n">tp_poly_region_one</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;lightseagreen&#39;</span><span class="p">,</span> <span class="n">edgecolor</span> <span class="o">=</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">rain_one</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;dimgray&#39;</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># Set title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;San Francisco Bay Area - One Point and Thiessen Polygon&#39;</span><span class="p">,</span> <span class="n">fontdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="s1">&#39;fontweight&#39;</span> <span class="p">:</span> <span class="s1">&#39;3&#39;</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, &#39;San Francisco Bay Area - One Point and Thiessen Polygon&#39;)
</pre></div>
</div>
<img alt="../_images/e_interpolation_23_1.png" src="../_images/e_interpolation_23_1.png" />
</div>
</div>
</div>
<div class="section" id="k-nearest-neighbors">
<h2>K-Nearest Neighbors<a class="headerlink" href="#k-nearest-neighbors" title="Permalink to this headline">¶</a></h2>
<p>KNN (also stylized as kNN) is a neighbor-based learning method that can be used for interpolation. Unlike the Thiessen polygons method, KNN looks for a specified number <code class="docutils literal notranslate"><span class="pre">K</span></code> of sampled points closest to an unknown point. The <code class="docutils literal notranslate"><span class="pre">K</span></code> known points can be used to predict the value (discrete or continuous) of the unknown point. <a class="footnote-reference brackets" href="#sk-nn" id="id4">3</a></p>
<p>We can use the <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsRegressor.html"><code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> module</a> to perform KNN analysis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set number of neighbors to look for</span>
<span class="n">neighbors</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># Initialize KNN regressor</span>
<span class="n">knn_regressor</span> <span class="o">=</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="s2">&quot;distance&quot;</span><span class="p">)</span>

<span class="c1"># Fit regressor to data</span>
<span class="n">knn_regressor</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">coords_rain_train</span><span class="p">,</span> <span class="n">value_rain_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>KNeighborsRegressor(weights=&#39;distance&#39;)
</pre></div>
</div>
</div>
</div>
<p>Now that we have created the KNN model, we can get the in-sample r-squared value. An in-sample statistic, as suggested by its name, is calculated by using the data that were used to build the model (the “training” dataset).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate in-sample R^2</span>
<span class="n">in_r_squared_knn</span> <span class="o">=</span> <span class="n">knn_regressor</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">coords_rain_train</span><span class="p">,</span> <span class="n">value_rain_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;KNN in-sample r-squared: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">in_r_squared_knn</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>KNN in-sample r-squared: 1.0
</pre></div>
</div>
</div>
</div>
<p>Here, the in-sample r-squared value is 100% because KNN is a “exact interpolator.” For exact interpolators, estimated values for known points are exactly equal to actual values. Other methods like Kriging, shown below, are inexact interpolators. For inexact interpolators, estimated values for known points are not exactly equal to actual values. Here’s a <a class="reference external" href="https://www.onestopgis.com/GIS-Theory-and-Techniques/Spatial-Interpolation/Elements-of-Spatial-Interpolation/posts/Types-of-Spatial-Interpolation/Image-shows-Exact-interpolation-and-Inexact-interpolation.png?__cf_chl_jschl_tk__=231d8a46e00aa6fe5352048bff01af55174b6c40-1625260397-0-ARqVOIsPHXJ9wPUqWrXKldltKnf_3GrT_RVaKb7djF6cUYCwnIzVeYww8nW4e_3GiIiCNZ15eVXmksePbUz-sKbuHtD2UsSh9OWZ4w2Y2dS_zCeIMCVRUIrYCjZEEcH722m7Y2vCDGAaA6gh1RObvtBx_3Se3gCdldO6c65zunRmX4vE0jLONpdckY6MEo4YPiyZr_11QAdPLYBWwgtl3wC2XhM5mhsmVYmInXWYTiyr35sXWVn86DedDNC2rKMnvrQGo8BuBgjskX6uf_Y3tWWpYCpyghV9s0zpygqgTQYG8rNaKJyFFQdoX--tMMEYY2AwzAI2BNmAxlGlxM07tBndOjZFgphEsU9nbFhOAB-Wji4u0wwD_N97FBKdFwsNl8bGbPSpLoiIMZ94GVZqETiD29W_lFPsiunLAt3EU2Ra-pf2QC1lCaUUhUt2aCIgHH6SnzTAm-JictSfAD4cnYolpP7D27Cj_UOGLSfo2sk4KcOH9JAG3ZGF1UCkX2fBUTivVWmuYPL4l1xaGS7e0BgKuiz_TdAbeMNkyi2TtWgMzT2sZEqf5QXZzvSwbsOVf5Z8ph6imf4gaHYhhYU87yKTDkK8PnYkbuyS3zeDWnM7hTj-Gn-LtNSYpiTjA68NZA">visual of inexact versus exact interpolators</a>.</p>
<p>Similarily, we can also get the out-of-sample r-squared value and compare the test dataset’s actual values to the values as predicted by the model.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate out-of-sample R^2</span>
<span class="n">out_r_squared_knn</span> <span class="o">=</span> <span class="n">knn_regressor</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">coords_rain_test</span><span class="p">,</span> <span class="n">value_rain_test</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;KNN out-of-sample r-squared: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">out_r_squared_knn</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

<span class="c1"># Predict values for testing dataset</span>
<span class="n">coords_rain_test_predict_knn</span> <span class="o">=</span> <span class="n">knn_regressor</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">coords_rain_test</span><span class="p">)</span>

<span class="c1"># Create dictionary holding the actual and predicted values</span>
<span class="n">predict_dict_knn</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Coordinate_Pair&quot;</span><span class="p">:</span> <span class="n">coords_rain_test</span><span class="p">,</span> <span class="s2">&quot;VALUE_Actual&quot;</span><span class="p">:</span> <span class="n">value_rain_test</span><span class="p">,</span> <span class="s2">&quot;VALUE_Predict&quot;</span><span class="p">:</span> <span class="n">coords_rain_test_predict_knn</span><span class="p">}</span>

<span class="c1"># Create dataframe from dictionary</span>
<span class="n">predict_df_knn</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">predict_dict_knn</span><span class="p">)</span>

<span class="c1"># Display attribute table</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attribute Table: Testing Set Interpolated Values - KNN Method&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">predict_df_knn</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>KNN out-of-sample r-squared: 0.93

Attribute Table: Testing Set Interpolated Values - KNN Method
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Coordinate_Pair</th>
      <th>VALUE_Actual</th>
      <th>VALUE_Predict</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>[-229633.02624581114, 40063.75429398427]</td>
      <td>56</td>
      <td>55.827992</td>
    </tr>
    <tr>
      <th>1</th>
      <td>[-273849.3497429455, 92453.68931061402]</td>
      <td>73</td>
      <td>87.640078</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Out-of-sample r-squared looks pretty strong!</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you are just interested in identifying the <code class="docutils literal notranslate"><span class="pre">k</span></code> nearest neighbors (no interpolation), use the <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.NearestNeighbors.html#sklearn.neighbors.NearestNeighbors"><code class="docutils literal notranslate"><span class="pre">NearestNeighbors()</span></code> function</a>.</p>
</div>
</div>
<div class="section" id="kriging">
<h2>Kriging<a class="headerlink" href="#kriging" title="Permalink to this headline">¶</a></h2>
<p>Kriging is a type of interpolation that uses a semivariogram, which measures spatial autocorrelation (how similar close points are in value and how this similarity changes as distance between points increases). Thus, the semivariogram determines how much influence a known point has on an unknown point as the distance between the known point and the unknown point increases. In other words, the weight of a known point on an unknown point decreases with increasing distance, and the semivariogram determines how quickly that weight tapers with increasing distance. <a class="footnote-reference brackets" href="#bolstad" id="id5">1</a>, <a class="footnote-reference brackets" href="#esri-kriging" id="id6">4</a></p>
<p>For more information, see this <a class="reference external" href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/3d-analyst/how-kriging-works.htm">ArcGIS help guide on kriging</a>.</p>
<p>Two Python packages that can be used for kriging include <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> and <code class="docutils literal notranslate"><span class="pre">pykrige</span></code>. The former package works best when the input data has a WGS 84 projection, so we will begin by reprojecting all of our data to that coordinate system (click the + below to show code cell).</p>
<div class="cell tag_hide-cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># Set projection to WGS 84 and reproject data</span>
<span class="sd">proj_wgs = 4326</span>
<span class="sd">counties_wgs = counties.to_crs(proj_wgs)</span>
<span class="sd">rainfall_wgs = rainfall.to_crs(proj_wgs)</span>
<span class="sd">rain_train_gdf_wgs = rain_train_gdf.to_crs(proj_wgs)</span>
<span class="sd">rain_test_gdf_wgs = rain_test_gdf.to_crs(proj_wgs)</span>

<span class="sd"># Get X and Y coordinates of rainfall points</span>
<span class="sd">x_rain_wgs = rainfall_wgs[&quot;geometry&quot;].x</span>
<span class="sd">y_rain_wgs = rainfall_wgs[&quot;geometry&quot;].y</span>

<span class="sd"># Create list of XY coordinate pairs</span>
<span class="sd">coords_rain_train_wgs = [list(xy) for xy in zip(rain_train_gdf_wgs[&quot;geometry&quot;].x, rain_train_gdf_wgs[&quot;geometry&quot;].y)]</span>
<span class="sd">coords_rain_test_wgs = [list(xy) for xy in zip(rain_test_gdf_wgs[&quot;geometry&quot;].x, rain_test_gdf_wgs[&quot;geometry&quot;].y)]</span>

<span class="sd"># Get minimum and maximum coordinate values of rainfall points</span>
<span class="sd">min_x_rain_wgs, min_y_rain_wgs, max_x_rain_wgs, max_y_rain_wgs = rain_train_gdf_wgs.total_bounds</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;\n# Set projection to WGS 84 and reproject data\nproj_wgs = 4326\ncounties_wgs = counties.to_crs(proj_wgs)\nrainfall_wgs = rainfall.to_crs(proj_wgs)\nrain_train_gdf_wgs = rain_train_gdf.to_crs(proj_wgs)\nrain_test_gdf_wgs = rain_test_gdf.to_crs(proj_wgs)\n\n# Get X and Y coordinates of rainfall points\nx_rain_wgs = rainfall_wgs[&quot;geometry&quot;].x\ny_rain_wgs = rainfall_wgs[&quot;geometry&quot;].y\n\n# Create list of XY coordinate pairs\ncoords_rain_train_wgs = [list(xy) for xy in zip(rain_train_gdf_wgs[&quot;geometry&quot;].x, rain_train_gdf_wgs[&quot;geometry&quot;].y)]\ncoords_rain_test_wgs = [list(xy) for xy in zip(rain_test_gdf_wgs[&quot;geometry&quot;].x, rain_test_gdf_wgs[&quot;geometry&quot;].y)]\n\n# Get minimum and maximum coordinate values of rainfall points\nmin_x_rain_wgs, min_y_rain_wgs, max_x_rain_wgs, max_y_rain_wgs = rain_train_gdf_wgs.total_bounds\n&#39;
</pre></div>
</div>
</div>
</div>
<div class="section" id="method-1-using-pykrige">
<h3>Method 1 - Using <code class="docutils literal notranslate"><span class="pre">PyKrige</span></code><a class="headerlink" href="#method-1-using-pykrige" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://geostat-framework.readthedocs.io/projects/pykrige/en/stable/index.html"><code class="docutils literal notranslate"><span class="pre">pykrige</span></code> module</a> offers ordinary and universal kriging. It also supports various variogram models in addition to Gaussian.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Adapted from: https://geostat-framework.readthedocs.io/projects/pykrige/en/latest/examples/04_krige_geometric.html</span>

<span class="c1"># Create a 100 by 100 grid</span>
<span class="c1"># Horizontal and vertical cell counts should be the same</span>
<span class="n">XX_pk_krig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_x_rain</span><span class="p">,</span> <span class="n">max_x_rain</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">YY_pk_krig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_y_rain</span><span class="p">,</span> <span class="n">max_y_rain</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1"># Generate ordinary kriging object</span>
<span class="n">OK</span> <span class="o">=</span> <span class="n">OrdinaryKriging</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x_rain</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_rain</span><span class="p">),</span>
    <span class="n">value_rain</span><span class="p">,</span>
    <span class="n">variogram_model</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">enable_plotting</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">coordinates_type</span> <span class="o">=</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Evaluate the method on grid</span>
<span class="n">Z_pk_krig</span><span class="p">,</span> <span class="n">sigma_squared_p_krig</span> <span class="o">=</span> <span class="n">OK</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;grid&quot;</span><span class="p">,</span> <span class="n">XX_pk_krig</span><span class="p">,</span> <span class="n">YY_pk_krig</span><span class="p">)</span>

<span class="c1"># Export raster</span>
<span class="n">export_kde_raster</span><span class="p">(</span><span class="n">Z</span> <span class="o">=</span> <span class="n">Z_pk_krig</span><span class="p">,</span> <span class="n">XX</span> <span class="o">=</span> <span class="n">XX_pk_krig</span><span class="p">,</span> <span class="n">YY</span> <span class="o">=</span> <span class="n">YY_pk_krig</span><span class="p">,</span>
                  <span class="n">min_x</span> <span class="o">=</span> <span class="n">min_x_rain</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">max_x_rain</span><span class="p">,</span> <span class="n">min_y</span> <span class="o">=</span> <span class="n">min_y_rain</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">max_y_rain</span><span class="p">,</span>
                  <span class="n">proj</span> <span class="o">=</span> <span class="n">proj</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;../temp/e_bay-area-rain_pk_kriging.tif&quot;</span><span class="p">)</span>

<span class="c1"># Open raster</span>
<span class="n">raster_pk</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;../temp/e_bay-area-rain_pk_kriging.tif&quot;</span><span class="p">)</span>


<span class="c1"># Create polygon with extent of raster</span>
<span class="n">poly_shapely</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">raster_pk</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>

<span class="c1"># Create a dictionary with needed attributes and required geometry column</span>
<span class="n">attributes_df</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Attribute&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;name1&#39;</span><span class="p">],</span> <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="n">poly_shapely</span><span class="p">}</span>

<span class="c1"># Convert shapely object to a GeoDataFrame</span>
<span class="n">raster_pk_extent</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">attributes_df</span><span class="p">,</span> <span class="n">geometry</span> <span class="o">=</span> <span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">crs</span> <span class="o">=</span> <span class="n">proj</span><span class="p">)</span>

<span class="c1"># Create copy of test dataset</span>
<span class="n">rain_test_gdf_pk_krig</span> <span class="o">=</span> <span class="n">rain_test_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Subset the GeoDataFrame by checking which test points are within the raster extent polygon</span>
<span class="c1"># If a test point is beyond the extent of training points dataset, the kriging output may not cover that test point</span>
<span class="n">rain_test_gdf_pk_krig</span> <span class="o">=</span> <span class="n">rain_test_gdf_pk_krig</span><span class="p">[</span><span class="n">rain_test_gdf_pk_krig</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">raster_pk_extent</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

<span class="c1"># Create list of XY coordinate pairs for the test points that fall within raster extent polygon</span>
<span class="n">coords_rain_test_pk_krig</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rain_test_gdf_pk_krig</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rain_test_gdf_pk_krig</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">)]</span>

<span class="c1"># Extract raster value at each test point and add the values to the GeoDataFrame</span>
<span class="n">rain_test_gdf_pk_krig</span><span class="p">[</span><span class="s2">&quot;VALUE_Predict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">raster_pk</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">coords_rain_test_pk_krig</span><span class="p">)]</span>

<span class="c1"># Generate out-of-sample R^2</span>
<span class="n">out_r_squared_tp</span> <span class="o">=</span> <span class="n">r2_score</span><span class="p">(</span><span class="n">rain_test_gdf_pk_krig</span><span class="o">.</span><span class="n">Actual_Value</span><span class="p">,</span> <span class="n">rain_test_gdf_pk_krig</span><span class="o">.</span><span class="n">VALUE_Predict</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PyKrige Kriging out-of-sample r-squared: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">out_r_squared_tp</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

<span class="c1"># Display attribute table</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attribute Table: Random Points Interpolated Values - PyKrige Kriging Method&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">rain_test_gdf_pk_krig</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>


<span class="c1"># Mask raster to counties shape</span>
<span class="n">out_image_pk</span><span class="p">,</span> <span class="n">out_transform_pk</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">raster_pk</span><span class="p">,</span> <span class="n">counties</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">crop</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># Stylize plots</span>
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;bmh&#39;</span><span class="p">)</span>

<span class="c1"># Plot data</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">show</span><span class="p">(</span><span class="n">out_image_pk</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">out_transform_pk</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s2">&quot;RdPu&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_rain</span><span class="p">,</span> <span class="n">y_rain</span><span class="p">,</span> <span class="s1">&#39;k.&#39;</span><span class="p">,</span> <span class="n">markersize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">counties</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span> <span class="o">=</span> <span class="s1">&#39;dimgray&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>

<span class="c1"># Set title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;San Francisco Bay Area - Interpolating Rainfall using Kriging from PyKrige&#39;</span><span class="p">,</span> <span class="n">fontdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="s1">&#39;fontweight&#39;</span> <span class="p">:</span> <span class="s1">&#39;3&#39;</span><span class="p">})</span>

<span class="c1"># Display plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>PyKrige Kriging out-of-sample r-squared: 0.99

Attribute Table: Random Points Interpolated Values - PyKrige Kriging Method
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>Actual_Value</th>
      <th>VALUE_Predict</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POINT (-229633.026 40063.754)</td>
      <td>56</td>
      <td>55.089479</td>
    </tr>
    <tr>
      <th>2</th>
      <td>POINT (-244809.950 1296.393)</td>
      <td>62</td>
      <td>61.013348</td>
    </tr>
  </tbody>
</table>
</div></div><img alt="../_images/e_interpolation_34_2.png" src="../_images/e_interpolation_34_2.png" />
</div>
</div>
</div>
<div class="section" id="method-2-using-scikit-learn">
<h3>Method 2- Using <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code><a class="headerlink" href="#method-2-using-scikit-learn" title="Permalink to this headline">¶</a></h3>
<p>Kriging can be performed using <a class="reference external" href="https://scikit-learn.org/stable/modules/gaussian_process.html">Gaussian processes from the <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> module</a> (Gaussian processes is essentially equivalent to kriging). Various kernels for Gaussian processes can be specified. We will continue to use the training and testing datasets created from our KNN analysis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># Create a 100 by 100 cell mesh grid</span>
<span class="sd"># Horizontal and vertical cell counts should be the same</span>
<span class="sd">XX_sk_krig, YY_sk_krig = np.mgrid[min_x_rain_wgs:max_x_rain_wgs:100j, min_y_rain_wgs:max_y_rain_wgs:100j]</span>

<span class="sd"># Create 2-D array of the coordinates (paired) of each cell in the mesh grid</span>
<span class="sd">positions_sk_krig = np.vstack([XX_sk_krig.ravel(), YY_sk_krig.ravel()]).T</span>

<span class="sd"># Generate Gaussian Process model (can change parameters as desired)</span>
<span class="sd">gp = GaussianProcessRegressor(n_restarts_optimizer = 10)</span>

<span class="sd"># Fit kernel density estimator to coordinates and values</span>
<span class="sd">gp.fit(coords_rain_train_wgs, value_rain_train)</span>

<span class="sd"># Evaluate the model on coordinate pairs</span>
<span class="sd">Z_sk_krig = gp.predict(positions_sk_krig)</span>

<span class="sd"># Reshape the data to fit mesh grid</span>
<span class="sd">Z_sk_krig = Z_sk_krig.reshape(XX_sk_krig.shape)</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;\n# Create a 100 by 100 cell mesh grid\n# Horizontal and vertical cell counts should be the same\nXX_sk_krig, YY_sk_krig = np.mgrid[min_x_rain_wgs:max_x_rain_wgs:100j, min_y_rain_wgs:max_y_rain_wgs:100j]\n\n# Create 2-D array of the coordinates (paired) of each cell in the mesh grid\npositions_sk_krig = np.vstack([XX_sk_krig.ravel(), YY_sk_krig.ravel()]).T\n\n# Generate Gaussian Process model (can change parameters as desired)\ngp = GaussianProcessRegressor(n_restarts_optimizer = 10)\n\n# Fit kernel density estimator to coordinates and values\ngp.fit(coords_rain_train_wgs, value_rain_train)\n\n# Evaluate the model on coordinate pairs\nZ_sk_krig = gp.predict(positions_sk_krig)\n\n# Reshape the data to fit mesh grid\nZ_sk_krig = Z_sk_krig.reshape(XX_sk_krig.shape)\n&#39;
</pre></div>
</div>
</div>
</div>
<p>Next, we can calculate our r-squared statistics and predictions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># Generate in-sample R^2</span>
<span class="sd">in_r_squared_sk_krig = gp.score(coords_rain_train_wgs, value_rain_train)</span>
<span class="sd">print(&quot;Scikit-Learn Kriging in-sample r-squared: {}&quot;.format(round(in_r_squared_sk_krig, 2)))</span>

<span class="sd"># Generate out-of-sample R^2</span>
<span class="sd">out_r_squared_sk_krig = gp.score(coords_rain_test_wgs, value_rain_test)</span>
<span class="sd">print(&quot;Scikit-Learn Kriging out-of-sample r-squared: {}&quot;.format(round(out_r_squared_sk_krig, 2)))</span>

<span class="sd"># Predict values for testing dataset</span>
<span class="sd">coords_rain_test_predict_sk_krig = gp.predict(coords_rain_test_wgs)</span>

<span class="sd"># Create dictionary holding the actual and predicted values</span>
<span class="sd">predict_dict_sk_krig = {&quot;Coordinate_Pair&quot;: coords_rain_test_wgs, &quot;VALUE_Actual&quot;: value_rain_test, &quot;VALUE_Predict&quot;: coords_rain_test_predict_sk_krig}</span>

<span class="sd"># Create dataframe from dictionary</span>
<span class="sd">predict_df_sk_krig = pd.DataFrame(predict_dict_sk_krig)</span>

<span class="sd"># Display attribute table</span>
<span class="sd">print(&quot;\nAttribute Table: Testing Set Interpolated Values - Scikit-Learn Kriging Method&quot;)</span>
<span class="sd">display(predict_df_sk_krig.head(2))</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;\n# Generate in-sample R^2\nin_r_squared_sk_krig = gp.score(coords_rain_train_wgs, value_rain_train)\nprint(&quot;Scikit-Learn Kriging in-sample r-squared: {}&quot;.format(round(in_r_squared_sk_krig, 2)))\n\n# Generate out-of-sample R^2\nout_r_squared_sk_krig = gp.score(coords_rain_test_wgs, value_rain_test)\nprint(&quot;Scikit-Learn Kriging out-of-sample r-squared: {}&quot;.format(round(out_r_squared_sk_krig, 2)))\n\n# Predict values for testing dataset\ncoords_rain_test_predict_sk_krig = gp.predict(coords_rain_test_wgs)\n\n# Create dictionary holding the actual and predicted values\npredict_dict_sk_krig = {&quot;Coordinate_Pair&quot;: coords_rain_test_wgs, &quot;VALUE_Actual&quot;: value_rain_test, &quot;VALUE_Predict&quot;: coords_rain_test_predict_sk_krig}\n\n# Create dataframe from dictionary\npredict_df_sk_krig = pd.DataFrame(predict_dict_sk_krig)\n\n# Display attribute table\nprint(&quot;\nAttribute Table: Testing Set Interpolated Values - Scikit-Learn Kriging Method&quot;)\ndisplay(predict_df_sk_krig.head(2))\n&#39;
</pre></div>
</div>
</div>
</div>
<p>Model seems like a good fit! Let’s export the raster.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># Flip array vertically and rotate 270 degrees</span>
<span class="sd">Z_sk_krig = np.rot90(np.flip(Z_sk_krig, 0), 3)</span>

<span class="sd"># Export raster</span>
<span class="sd">export_kde_raster(Z = Z_sk_krig, XX = XX_sk_krig, YY = YY_sk_krig,</span>
<span class="sd">                  min_x = min_x_rain_wgs, max_x = max_x_rain_wgs, min_y = min_y_rain_wgs, max_y = max_y_rain_wgs,</span>
<span class="sd">                  proj = proj_wgs, filename = ../temp/e_bay-area-rain_sk_kriging.tif&quot;)</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;\n# Flip array vertically and rotate 270 degrees\nZ_sk_krig = np.rot90(np.flip(Z_sk_krig, 0), 3)\n\n# Export raster\nexport_kde_raster(Z = Z_sk_krig, XX = XX_sk_krig, YY = YY_sk_krig,\n                  min_x = min_x_rain_wgs, max_x = max_x_rain_wgs, min_y = min_y_rain_wgs, max_y = max_y_rain_wgs,\n                  proj = proj_wgs, filename = ../temp/e_bay-area-rain_sk_kriging.tif&quot;)\n&#39;
</pre></div>
</div>
</div>
</div>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>The resulting raster should be clipped. Because the resulting raster covers the extent of the points in a bounding box fashion, the raster in this case covers areas that are not within the counties boundaries (such as in the ocean) where we do not have sample points. Thus, there will be interpolated values in those areas that might not make sense.</p>
</div>
<p>Finally, we import the raster, mask it to the counties boundaries, and plot the data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># Open raster</span>
<span class="sd">raster_sk = rasterio.open(&quot;../temp/e_bay-area-rain_sk_kriging.tif&quot;)</span>

<span class="sd"># Mask raster to counties shape</span>
<span class="sd">out_image_sk, out_transform_sk = rasterio.mask.mask(raster_sk, counties_wgs.geometry.values, crop = True)</span>

<span class="sd"># Stylize plots</span>
<span class="sd">plt.style.use(&#39;bmh&#39;)</span>

<span class="sd">### Method 2- Using `scikit-learn`</span>

<span class="sd">Kriging can be performed using [Gaussian processes from the `scikit-learn` module](https://scikit-learn.org/stable/modules/gaussian_process.html) (Gaussian processes is essentially equivalent to kriging). Various kernels for Gaussian processes can be specified. We will continue to use the training and testing datasets created from our KNN analysis.</span>

<span class="sd">```{code-cell} ipython3</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="c1"># Create a 100 by 100 cell mesh grid</span>
<span class="c1"># Horizontal and vertical cell counts should be the same</span>
<span class="n">XX_sk_krig</span><span class="p">,</span> <span class="n">YY_sk_krig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">min_x_rain_wgs</span><span class="p">:</span><span class="n">max_x_rain_wgs</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">,</span> <span class="n">min_y_rain_wgs</span><span class="p">:</span><span class="n">max_y_rain_wgs</span><span class="p">:</span><span class="mi">100</span><span class="n">j</span><span class="p">]</span>

<span class="c1"># Create 2-D array of the coordinates (paired) of each cell in the mesh grid</span>
<span class="n">positions_sk_krig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">XX_sk_krig</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">YY_sk_krig</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>

<span class="c1"># Generate Gaussian Process model (can change parameters as desired)</span>
<span class="n">gp</span> <span class="o">=</span> <span class="n">GaussianProcessRegressor</span><span class="p">(</span><span class="n">n_restarts_optimizer</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>

<span class="c1"># Fit kernel density estimator to coordinates and values</span>
<span class="n">gp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">coords_rain_train_wgs</span><span class="p">,</span> <span class="n">value_rain_train</span><span class="p">)</span>

<span class="c1"># Evaluate the model on coordinate pairs</span>
<span class="n">Z_sk_krig</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">positions_sk_krig</span><span class="p">)</span>

<span class="c1"># Reshape the data to fit mesh grid</span>
<span class="n">Z_sk_krig</span> <span class="o">=</span> <span class="n">Z_sk_krig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">XX_sk_krig</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="s1">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">  File</span><span class="nn"> &quot;&lt;ipython-input-21-7a1a306cd294&gt;&quot;</span><span class="gt">, line </span><span class="mi">35</span>
    <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">       ^</span>
<span class="ne">SyntaxError</span>: EOF while scanning triple-quoted string literal
</pre></div>
</div>
</div>
</div>
<p>Next, we can calculate our r-squared statistics and predictions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># Generate in-sample R^2</span>
<span class="sd">in_r_squared_sk_krig = gp.score(coords_rain_train_wgs, value_rain_train)</span>
<span class="sd">print(&quot;Scikit-Learn Kriging in-sample r-squared: {}&quot;.format(round(in_r_squared_sk_krig, 2)))</span>

<span class="sd"># Generate out-of-sample R^2</span>
<span class="sd">out_r_squared_sk_krig = gp.score(coords_rain_test_wgs, value_rain_test)</span>
<span class="sd">print(&quot;Scikit-Learn Kriging out-of-sample r-squared: {}&quot;.format(round(out_r_squared_sk_krig, 2)))</span>

<span class="sd"># Predict values for testing dataset</span>
<span class="sd">coords_rain_test_predict_sk_krig = gp.predict(coords_rain_test_wgs)</span>

<span class="sd"># Create dictionary holding the actual and predicted values</span>
<span class="sd">predict_dict_sk_krig = {&quot;Coordinate_Pair&quot;: coords_rain_test_wgs, &quot;VALUE_Actual&quot;: value_rain_test, &quot;VALUE_Predict&quot;: coords_rain_test_predict_sk_krig}</span>

<span class="sd"># Create dataframe from dictionary</span>
<span class="sd">predict_df_sk_krig = pd.DataFrame(predict_dict_sk_krig)</span>

<span class="sd"># Display attribute table</span>
<span class="sd">print(&quot;\nAttribute Table: Testing Set Interpolated Values - Scikit-Learn Kriging Method&quot;)</span>
<span class="sd">display(predict_df_sk_krig.head(2))</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
</div>
<p>Model seems like a good fit! Let’s export the raster.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># Flip array vertically and rotate 270 degrees</span>
<span class="sd">Z_sk_krig = np.rot90(np.flip(Z_sk_krig, 0), 3)</span>

<span class="sd"># Export raster</span>
<span class="sd">export_kde_raster(Z = Z_sk_krig, XX = XX_sk_krig, YY = YY_sk_krig,</span>
<span class="sd">                  min_x = min_x_rain_wgs, max_x = max_x_rain_wgs, min_y = min_y_rain_wgs, max_y = max_y_rain_wgs,</span>
<span class="sd">                  proj = proj_wgs, filename = ../temp/e_bay-area-rain_sk_kriging.tif&quot;)</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>The resulting raster should be clipped. Because the resulting raster covers the extent of the points in a bounding box fashion, the raster in this case covers areas that are not within the counties boundaries (such as in the ocean) where we do not have sample points. Thus, there will be interpolated values in those areas that might not make sense.</p>
</div>
<p>Finally, we import the raster, mask it to the counties boundaries, and plot the data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># Open raster</span>
<span class="sd">raster_sk = rasterio.open(&quot;../temp/e_bay-area-rain_sk_kriging.tif&quot;)</span>

<span class="sd"># Mask raster to counties shape</span>
<span class="sd">out_image_sk, out_transform_sk = rasterio.mask.mask(raster_sk, counties_wgs.geometry.values, crop = True)</span>

<span class="sd"># Stylize plots</span>
<span class="sd">plt.style.use(&#39;bmh&#39;)</span>

<span class="sd"># Plot data</span>
<span class="sd">fig, ax = plt.subplots(1, figsize = (10, 10))</span>
<span class="sd">show(out_image_sk, ax = ax, transform = out_transform_sk, cmap = &quot;RdPu&quot;)</span>
<span class="sd">ax.plot(x_rain_wgs, y_rain_wgs, &#39;k.&#39;, markersize = 2, alpha = 0.5)</span>
<span class="sd">counties_wgs.plot(ax = ax, color = &#39;none&#39;, edgecolor = &#39;dimgray&#39;)</span>
<span class="sd">plt.gca().invert_yaxis()</span>

<span class="sd"># Set title</span>
<span class="sd">ax.set_title(&#39;San Francisco Bay Area - Interpolating Rainfall using Kriging from Scikit-Learn&#39;, fontdict = {&#39;fontsize&#39;: &#39;15&#39;, &#39;fontweight&#39; : &#39;3&#39;})</span>

<span class="sd"># Display plot</span>
<span class="sd">plt.show()</span>


<span class="sd"># Plot data</span>
<span class="sd">fig, ax = plt.subplots(1, figsize = (10, 10))</span>
<span class="sd">show(out_image_sk, ax = ax, transform = out_transform_sk, cmap = &quot;RdPu&quot;)</span>
<span class="sd">ax.plot(x_rain_wgs, y_rain_wgs, &#39;k.&#39;, markersize = 2, alpha = 0.5)</span>
<span class="sd">counties_wgs.plot(ax = ax, color = &#39;none&#39;, edgecolor = &#39;dimgray&#39;)</span>
<span class="sd">plt.gca().invert_yaxis()</span>

<span class="sd"># Set title</span>
<span class="sd">ax.set_title(&#39;San Francisco Bay Area - Interpolating Rainfall using Kriging from Scikit-Learn&#39;, fontdict = {&#39;fontsize&#39;: &#39;15&#39;, &#39;fontweight&#39; : &#39;3&#39;})</span>

<span class="sd"># Display plot</span>
<span class="sd">plt.show()</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
</div>
</div>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="bolstad"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id5">3</a>)</span></dt>
<dd><p>GIS Fundamentals: A First Text on Geographic Information Systems, 5th ed., Paul Bolstad</p>
</dd>
<dt class="label" id="scipy-voronoi"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Voronoi.html">scipy.spatial.Voronoi, SciPy</a></p>
</dd>
<dt class="label" id="sk-nn"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p><a class="reference external" href="https://scikit-learn.org/stable/modules/neighbors.html">Nearest Neighbors, scikit-learn</a></p>
</dd>
<dt class="label" id="esri-kriging"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p><a class="reference external" href="https://pro.arcgis.com/en/pro-app/latest/tool-reference/3d-analyst/how-kriging-works.htm">How Kriging works, Esri</a></p>
</dd>
</dl>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./docs"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="e_vector_merge_dissolve.html" title="previous page">Merge Data &amp; Dissolve Polygons</a>
    <a class='right-next' id="next-link" href="e_raster_op_intro.html" title="next page">Raster Operations</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Michael Mann, Steven Chao, Jordan Graesser, Nina Feldman<br/>
        
          <div class="extra_footer">
            <div>
    <b>Supported by:</b>  <br>
    <a href="https://geography.columbian.gwu.edu/">
 <img alt="GW Geography" src="../_static/global/GWBlue.png"
  width="300" align="left">
</div>
<div>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" ><img align="right" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a> 
</div>

          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
    <!-- Google Analytics -->
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-192844775-1', 'auto');
      ga('set', 'anonymizeIp', true);
      ga('send', 'pageview');
    </script>
    <script async src='https://www.google-analytics.com/analytics.js'></script>
    <!-- End Google Analytics -->
    
  </body>
</html>